# Phase 5: Code Generation
In this final phase of our term project, we convert SnuPL/2's three-address code to assembly code that can be compiled and run on the target machine.

[[_toc_]]

## Description

In this fifth and last phase of our project, the TAC IR of SnuPL/2 is converted to assembly. At the end of this phase, your SnuPL/2 compiler is complete: it takes programs written in SnuPL/2 as inputs and outputs assembly code that can be compiled by an assembler into an executable file.

The reference implementation uses a simple template-based code generator for x86_64 with a memory-to-memory model, i.e., register allocation is not required. You are free to choose another target architecture than x86_64 or implement register allocation to make your code more efficient.


## Your Task

Despite its simplicity, there are a number of tasks that your code generator has to take care of such as:
* Assign a storage location to all variables (globals, locals, temporaries, and parameters).
* Layout the procedure activation frame, i.e., determine the location and stack offsets for all values stored on the stack.
* Emit initialized global data. This includes array meta data and string constants.
* Emit code for initialized local data. Also here, we need to emit code that generates the meta data of arrays on the stack.


### Overview

The following pseudo-code illustrates the steps of our code generator:
```C
Input: program in IR
Output: assembly
Pseudo-code:

  Emit(program):
      EmitCode(program)
      EmitData(program)


  EmitCode(program):
      forall s ∈ subscopes do
          EmitScope(s)

      EmitScope(program)


  EmitData(program):
      EmitGlobalData(program)


  EmitGlobalData(program):
      forall d ∈ globals do
          EmitGlobal(d)


  EmitScope(scope):
      ComputeStackOffsets(scope)

      emit function prologue
      InitializeLocalData(scope)

      forall i ∈ instructions do
        EmitInstruction(i)

      emit function epilogue


  EmitInstruction(i):
      load operands into registers
      perform operation
      write result back to memory


  InitializeLocalScope(scope):
      forall arrays a ∈ local variables in scope do
          initialize meta-data for a on stack


  ComputeStackOffsets(scope):
      forall v ∈ local variables and parameters in scope do
          compute stack offset and store in symbol table

      return total size of stack frame
```

The repository includes a minimal introduction to [the x86-64 ISA](specification/x86-64.md) and [the AT&T x86 assembly file format](specification/ATTassembly.md). The latter includes a skeleton file which will help you get started. 
Useful commands and tricks for debugging are provided in the [GNU debugger handout](specification/GDB.md).

All necessary modifications in this phase go into the AMD64 backend implemented in `src/backendAMD64.cpp/h`. 
To help you get started, the overall structure of the backend and some helper functions are already provided. 
In addition, the function that emits the global data has been implemented. 
Your job is to fill in the missing parts.

Note that it is possible that you will have to revisit parsing, semantic analysis, or IR code generation to make your compiler work properly with the backend. 


### The SnuPL/2 Runtime Library
Until now, we have allowed several functions and procedures in our code that did not have an actual implementation, such as `Read*()`, `Write*()` and `DIM()` and `DOFS()`. 

The implementation of these methods is provided by the SnuPL/2 runtime library (RTL). You can find the source code for x86_64 in the directory `snuplc\rte\x86_64`. The I/O methods are implemented in C, array handling functions are provided as assembly code. 

You need to compile the SnuPL/2 RTL only once.
```bash
  $ cd snupl/rtl/x86-64
  $ make
```

The provided Makefile generates a static library to avoid the trouble of locating the dynamically linked shared library when executing an SnuPL/2 program. 

If you choose to generate code for a different architecture than AMD x86_64, you will need to implement the array functions `DIM()` and `DOFS()` manually.


### Building your compiler
The Makefile of this phase builds the final compiler `snuplc`. The compiler provides a number of command line options - have a look at the output of `snuplc --help` to learn more.
```bash
  $ cd snuplc
  $ make
  $ ./snuplc --help
```


### Linking with the SnuPL/2 RTL
The assembly files generated by `snuplc` can be assembled into an executable file with GCC. If the compiled program calls I/O routines or arrays functions, the SnuPL/2 RTL needs to be linked to the generated assembly code as follows:
```bash
  $ cd test/codegen
  $ ../../snuplc/snuplc test01.mod
  $ gcc -L../../snuplc/rtl/x86-64 -o test01 test01.mod.s -lsnupl
```
Now, you can execute the program with
```bash
  $ ./test01
```

The compiler invokes GCC directly if executed with the `--exe` argument. The compiler assumes that the SnuPL/2 RTL can be found in the `rtl/` subdirectory, so you may want to create a symbolic link to the RTL in your test directory. While you're at it, also create a link to snuplc to avoid typing the full relative path every time you invoke `snuplc`:
```bash
  $ cd test/codegen
  $ ln -s ../../snuplc/snuplc
  $ ln -s ../../snuplc/rtl
  $ ./snuplc --exe test21.mod
  compiling test21.mod...
  running command 'gcc -m64 -march=x86-64 -Lrte//x86-64 -o test21 test21.mod.s -lsnupl'...

  $ ./test21
  Prime factoring

  Enter number to factor: 4109409
  prime factors of 4109409:  3 3 59 71 109
  $
```

### Reference implementation
As usual, the reference implementation can be found in the directory `snuplc/reference`.

Test files for this phase are located in the directory `test/codegen/`. We advise you to create your own test cases that go beyond the provided test cases as we use our own set of test files to test (and grade) your submission.



## Inline Documentation
Our SnuPL/2 compiler and the skeleton code are fully documented with Doxygen.
You can generate the documentation from your sources by running 
```bash
snuplc $ make doc
```
from the `snuplc` directory. You will need to install Doxygen and Graphviz (dot) on your machine.


## Materials to submit
* Source code  
  Document your code properly - including Doxygen comments for all new classes, member functions, and fields.
  Please do not include any generated files (documentation, relocateable object files, binaries) into your GitLab repository. We will compile your code by ourselves.

* A brief report describing your implementation of the code generator in PDF format  
  The report must be stored as `reports/5.Code.Generation.pdf`.

* **Final report (due Tuesday, December 12)**  
  The report must be stored as `reports/6.SnuPLC.pdf`.  
  If you put sufficient effort into the reports for the individual phases, you can start by contatenating all these reports, otherwise, you will have significantly more work to do.
  Make sure that the report is structured properly, has a table of contents. For example, one section per phase, plus an introduction, a discussion/lessons learned, and a conclusion seem appropriate. 
  There should be sufficient text and descriptions - a report comprising mostly screenshots will not receive full points. In general, graphical figures should only be used for diagrams, graphs, etc. Code should be formatted as text.
  Remember that the final report is almost as important as your code. Make sure to put sufficient effort into it!


## Final words
Implementing a compiler is difficult. Do not hesitate to ask questions in class and on Slack. 
Also, start as soon as possible; if you wait until a few days before the deadline we cannot help you much and you may not be able to finish in time.

Happy coding!
